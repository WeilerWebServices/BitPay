#!/usr/bin/env node
// MIT/X11-like license.  See LICENSE.txt.
// Copyright 2013 BitPay, Inc.
require('classtool');

function spec(b) {

  var buffertools = b.buffertools || require('buffertools');
  var fs = b.fs || require('fs');
  var BitcoinRPC = b.BitcoinRPC || require('bitcore/RpcClient').class();
  var Transaction = b.Transaction || require('bitcore/Transaction').class();
  var Address = b.Address || require('bitcore/Address').class();
  var Wallet = b.Wallet || require('bitcore/Wallet').class();
  var WalletKey = b.WalletKey || require('bitcore/WalletKey').class();
  var KeyModule = b.KeyModule || require('bitcore/Key');
  var networks = b.networks || require('bitcore/networks');
  var PrivateKey = b.PrivateKey || require('bitcore/PrivateKey').class();
  var Script = b.Script || require('bitcore/Script').class();
  var coinUtil = b.coinUtil || require('bitcore/util/util');
  var Parser = b.Parser || require('bitcore/util/BinaryParser').class();
  var async = b.async || require('async');
  var bignum = b.bignum || require('bignum');
  var program = b.program || require('commander');
  var TXTOOL_VERSION = '0.2';
  
  function Cosign(argv) {
    var self = this;
    if (!argv)
      argv = process.argv;
    this.program = program;
    this.program
      .version(TXTOOL_VERSION)
      .option('-f, --file [file]', 'Load/store transaction state to/from JSON file [txstatedb.json]', 'txstatedb.json')
      .option('-P, --pass [passphrase]', 'AES wallet passphrase')
      .option('-w, --wallet [file]', 'AES wallet filename')
      .option('--rpcport [port]', 'Bitcoind RPC port [18332]', Number, 18332)
      .option('--rpcuser [user]', 'Bitcoind RPC user [user]', String, 'user')
      .option('--rpcpass [password]', 'Bitcoind RPC password [pass]', String, 'pass')
      .parse(argv);

    this.rpc = new BitcoinRPC({
        'port' : self.program.rpcport,
        'user' : self.program.rpcuser,
        'pass' : self.program.rpcpass,
        'protocol' : 'http'
    });
  
    this.statedb_fn = this.program.file;
    
    // Our empty wallet defaults
    this.wallet = undefined;
    this.network = undefined;
    
    this.datastore = {};
    
    if (this.program.wallet) {
      this.wallet = new Wallet();
      this.wallet.datastore.client = 'cosign';
      this.wallet.datastore.client_version = TXTOOL_VERSION;
      this.wallet.datastore.network = 'livenet';
    
      //wallet load
      this.wallet.readSync(this.program.wallet, this.program.pass);

      //network load
      this.wallet.setNetwork(this.wallet.datastore.network);
      this.network = this.wallet.network;
    }
  }
  this.class = Cosign;

  Cosign.prototype.wallet_store = function()
  {
    this.wallet.writeSync(this.program.wallet, this.program.pass);
  }
    
  Cosign.prototype.list_commands = function()
  {
    var s = "cosign command summary:\n";
    s += "clean\t\tRemove transaction state database\n";
    s += "dump\t\tInspect internal transaction state\n";
    s += "help\t\tList this command summary\n";
    s += "init\t\tInitialize new transaction state database\n";
    s += "inputs TXID1 VOUT1 TXID2 VOUT2...\n\t\tAppend inputs to TX\n";
    s += "inputs.clear\tClear list of inputs\n";
    s += "inputtxs.clear\tClear list of input transactions\n";
    s += "inputtxs.get\tRetrieve the full transactions for each input\n";
    s += "multisig N-REQUIRED KEY1 KEY2 KEY3...\n\t\tBegin new multi-sig tx\n";
    s += "nreq N-REQUIRED\tSpecific number of sigs required for a multisig tx\n";
    s += "redeem.clear\tClear redeem script\n";
    s += "redeem.create\tCreate redeem script\n";
    s += "outputs ADDRESS1 VALUE1 ADDRESS2 VALUE2...\n\t\tAppend outs to TX\n";
    s += "outputs.clear\tClear list of TX outputs\n";
    s += "pubkey.get ADDRESS\n\t\tLookup pubkey in wallet, given bitcoin address\n";
    s += "pubkeys KEY1 KEY2 KEY3...\n\t\tAdd to list of pubkeys / bitcoin addresses\n";
    s += "pubkeys.clear\tClear list of pubkeys\n";
    s += "raw SERIALIZED-TX\n\t\tInput serialized transaction from command line\n";
    s += "raw.append FILE\tAppend FILE to serialized transaction data\n";
    s += "raw.clear\tClear serialized tx data\n";
    s += "raw.create\tCreate raw tx, given inputs/outputs parameters\n";
    s += "raw.decode\tDecode raw tx, to JSON object\n";
    s += "raw.get TXID\tGet raw tx, given hash txid\n";
    s += "raw.read FILE\tInput serialized transaction from file\n";
    s += "raw.send\tSend raw tx to network via RPC\n";
    s += "raw.sign [anyonecanpay]\tSign transaction, if possible\n";
    s += "raw.write FILE\tOutput serialize transaction to file\n";
    s += "validate.all\tRun all validations for p2sh multisig transactions\n";
    s += "validate.fees\tCalculate miner fees\n";
    s += "validate.inputs\tValidate that the raw inputs match the inputs\n";
    s += "validate.inputtxs\n\t\tValidate that the inputtxs match the inputs\n";
    s += "validate.outputs\n\t\tValidate that the raw outputs match the outputs\n";
    s += "validate.p2sh\tValidate the p2sh address corresponds to the redeem script.\n"
    s += "validate.pubkeys\n\t\tValidate which pubkeys for which you have the private key\n";
    s += "validate.redeem\tValidate that redeem script matches public keys and nreq\n";
    s += "validate.sigs\tCount and validate signatures in the raw transaction\n";
    s += "wallet.msig\tCommit in-memory multisig data to wallet,\n\t\treturning a multisig payment address.\n";
    console.log(s);
  }
  
  Cosign.prototype.remove_database = function(callback)
  {
    var self = this;
    fs.exists(self.statedb_fn, function(exists) {
      if (exists)
        fs.unlink(self.statedb_fn, function(err) {
          if (err) throw err;
          callback();
        });
    });
  }
  
  Cosign.prototype.write_datastore = function(callback)
  {
    var self = this;
    var tmp_fn = this.statedb_fn + ".tmp";
  
    fs.writeFile(tmp_fn, JSON.stringify(this.datastore), function(err) {
      if (err) throw err;
      fs.rename(tmp_fn, self.statedb_fn, callback);
    });
  }
  
  Cosign.prototype.parse_nreq = function(idx)
  {
    if (idx >= this.program.args.length) {
      throw new Error("N-Required argument missing");
    }
  
    var re = /^\d+$/;
    var arg = this.program.args[idx];
    if (!re.test(arg)) {
      throw new Error("Invalid N-Required argument");
    }
  
    var n_req = parseInt(arg, 10);
    if (n_req < 1 || n_req > 50) {
      throw new Error("Out of range N-Required arg");
    }
  
    this.datastore['n_required'] = n_req;
  }
  
  Cosign.prototype.parse_pubkeys = function(start_idx)
  {
    // init 'pubkeys'
    if (this.datastore['pubkeys'] == undefined)
      this.datastore['pubkeys'] = [];
  
    // append to list of pubkeys
    for (var i = start_idx; i < this.program.args.length; i++) {
      this.datastore['pubkeys'].push(String(this.program.args[i]));
    }
  }
  
  Cosign.prototype.cmd_multisig = function()
  {
    this.parse_nreq(1);
  
    this.datastore['pubkeys'] = [];  // clear, if not already
    this.parse_pubkeys(2);
  
    this.write_datastore(function(err) {});
  }
  
  Cosign.prototype.cmd_nreq = function()
  {
    this.parse_nreq(1);
    this.write_datastore(function(err) {});
  }

  Cosign.prototype.cmd_redeem_create = function()
  {
    var pubkeys = [];
    for (var i in this.datastore['pubkeys'])
      pubkeys[i] = new Buffer(this.datastore['pubkeys'][i], 'hex');
    var script = Script.createMultisig(this.datastore['n_required'], pubkeys);
    this.datastore.redeemScript = script.buffer.toString('hex');
    this.write_datastore(function() {});
  }

  Cosign.prototype.cmd_validate_redeem_internal = function()
  {
    var pubkeys = [];

    for (var i in this.datastore['pubkeys'])
      pubkeys[i] = new Buffer(this.datastore['pubkeys'][i], 'hex');

    var script = Script.createMultisig(this.datastore['n_required'], pubkeys);
    var hex = script.buffer.toString('hex');

    if (hex == this.datastore.redeemScript)
      return true;
    else
      return false;
  }

  Cosign.prototype.cmd_validate_redeem = function()
  {
    var match = this.cmd_validate_redeem_internal();
    if (match)
      console.log('Success: redeem script corresponds to nreq and pubkeys.');
    else
      console.log('Failure: redeem script does not correspond to nreq and pubkeys.');
  }

  Cosign.prototype.cmd_validate_sigs_internal = function()
  {
    var self = this;
    var txbuf = new Buffer(self.datastore.raw, 'hex');
    var tx = new Transaction();
    tx.parse(txbuf);
    var ins = tx.ins;

    if (ins.length > 1)
      return -1; //TODO: support multiple inputs

    var txin = ins[0];
    var s = txin.s;
    var script = new Script(s);

    //assume inputs are p2sh multisig created by cosign
    if (s.length == 0)
      return 0;
    
    var sigsbuf = [];
    var nsigs = 0;
    for (var i = 0; i < script.chunks.length - 1; i++) {
      sigsbuf[i] = script.chunks[i];

      if (sigsbuf[i] != 0) {
        nsigs++;
        //TODO: actually verify signature
      }
    }

    return nsigs;
  }

  Cosign.prototype.cmd_validate_sigs = function()
  {
    var self = this;
    var nreq = self.datastore.n_required;
    var nsigs = self.cmd_validate_sigs_internal();

    if (nsigs >= 0 && nsigs == nreq)
      console.log('Success: all ' + nreq + ' signatures found.');
    else if (nsigs >= 0 && nsigs < nreq)
      console.log('Success: ' + nsigs + ' signatures found. ' + (nreq-nsigs) + ' more required.');
    else
      console.log('Failure: Signatures invalid.');
  }

  Cosign.prototype.cmd_validate_all = function()
  {
    console.log('validate.fees:');
    this.cmd_validate_fees();
    console.log('\nvalidate.inputs:');
    this.cmd_validate_inputs();
    console.log('\nvalidate.inputtxs:');
    this.cmd_validate_inputtxs();
    console.log('\nvalidate.outputs:');
    this.cmd_validate_outputs();
    console.log('\nvalidate.p2sh:');
    this.cmd_validate_p2sh();
    console.log('\nvalidate.pubkeys:');
    this.cmd_validate_pubkeys();
    console.log('\nvalidate.redeem:');
    this.cmd_validate_redeem();
    console.log('\nvalidate.sigs:');
    this.cmd_validate_sigs();
  }

  Cosign.prototype.cmd_validate_fees_internal = function()
  {
    var self = this;
    var outval = 0;
    var outputs = self.datastore.outputs;
    for (var i in outputs)
      outval += coinUtil.parseValue(outputs[i]);

    var inval = new bignum(0);
    var inputs = self.datastore.inputs;
    for (var i in inputs) {
      var input = inputs[i];
      var input_txid = input.txid;
      var input_n = input.vout;
      var txhex = self.datastore.inputtxs[input_txid];
      var txbuf = new Buffer(txhex, 'hex');
      var tx = new Transaction();
      tx.parse(txbuf);
      inval = inval.add(new bignum(tx.outs[input_n].getValue()));
    }

    var fees = inval.sub(outval);
    var fees_btc = fees.toNumber() * 1e-8;
    return fees_btc;
  }

  Cosign.prototype.cmd_validate_fees = function()
  {
    var self = this;
    var fees = self.cmd_validate_fees_internal();
    console.log('Fees: ' + fees + ' BTC');
    if (fees <= 0.0002 && fees > 0)
      console.log('Success: fees are reasonable.');
    else if (fees > 0)
      console.log('Failure: fees are too high.');
    else if (fees == 0)
      console.log('Failure: fees are zero.');
    else
      console.log('Failure: fees are negative.');
  }
  
  Cosign.prototype.ds_push_pubkey = function(pubkeyStr)
  {
    if (this.datastore['pubkeys'] == undefined)
      this.datastore['pubkeys'] = [];
  
    this.datastore['pubkeys'].push(pubkeyStr);
  
    console.log(pubkeyStr);
  }
  
  Cosign.prototype.pubkey_get_cb = function(err, resp)
  {
    if (err) throw new Error(err['message']);
    if (!resp['result']['pubkey'])
      throw new Error("Unable to obtain pubkey from RPC wallet");
  
    ds_push_pubkey(String(resp['result']['pubkey']));
    write_datastore(function(err) {});
  }
  
  Cosign.prototype.cmd_pubkey_get_file = function(addrStr)
  {
    var addr = new Address(addrStr);
    var obj = this.wallet.findKeyHash(addr.payload());
    if (!obj)
      throw new Error("Unable to obtain pubkey from wallet");
  
    this.ds_push_pubkey(obj.pub);
    this.write_datastore(function(err) {});
  }
  
  Cosign.prototype.cmd_pubkey_get = function(address)
  {
    var self = this;
    if (this.wallet)
      this.cmd_pubkey_get_file(address);
    else
      this.rpc.validateAddress(address, this.pubkey_get_cb.bind(self));
  }
  
  Cosign.prototype.cmd_pubkeys = function()
  {
    this.parse_pubkeys(1);
    this.write_datastore(function(err) {});
  }

  Cosign.prototype.cmd_validate_pubkeys_file = function()
  {
    var nkeys = 0;
    var keys = {};
    for (var i in this.datastore.pubkeys) {
      var pubkey = this.datastore.pubkeys[i];

      var haskey = false;

      for (var j in this.wallet.datastore.keys) {

        //pubkey should be what's recorded in wallet
        var key = this.wallet.datastore.keys[j];
        var pubkey2 = key.pub.toString('hex');

        //pubkey should be what can be rederived from private key
        var pkey = new PrivateKey(key.priv);
        var eckey = new KeyModule.Key.generateSync();
        var buf = new Buffer(pkey.as('hex'), 'hex');
        eckey.private = new Buffer(pkey.payload());
        eckey.compressed = pkey.compressed();
        eckey.regenerateSync();
        var pubkey3 = eckey.public.toString('hex');

        if (pubkey2 == pubkey && pubkey3 == pubkey) {
          haskey = true;
          nkeys++;
          break;
        }
      }

      keys[pubkey] = haskey;
    }

    if (nkeys == 0)
      return false;
    else
      return keys;
  }

  Cosign.prototype.cmd_validate_pubkeys_rpc = function()
  {
    console.log('Failure: validate.pubkeys for bitcoind wallet not implemented yet.');
  }

  Cosign.prototype.cmd_validate_pubkeys = function()
  {
    var self = this;
    var keys = [];

    if (self.wallet)
      keys = self.cmd_validate_pubkeys_file();
    else
      keys = self.cmd_validate_pubkeys_rpc();

    if (keys) {
      for (var i in self.datastore.pubkeys) {
        var pubkey = self.datastore.pubkeys[i];
        var haskey = keys[pubkey];
        console.log(pubkey, haskey ? "found" : "no");
      }
      console.log('Success: one or more public keys with corresponding private key found.');
    }
    else
      console.log('Failure: no public keys with corresponding private key found.');
  }
  
  Cosign.prototype.cmd_inputs = function()
  {
    if (this.datastore['inputs'] == undefined)
      this.datastore['inputs'] = [];
  
    for (var i = 1; i < this.program.args.length; i += 2) {
      var txid = String(this.program.args[i]);
      var vout = this.program.args[i + 1];
      var obj = {
        'txid' : txid,
        'vout' : vout
      };
  
      this.datastore['inputs'].push(obj);
    }
  
    this.write_datastore(function(err) {});
  }

  Cosign.prototype.cmd_inputtxs_get = function()
  {
    var self = this;
    var inputs = self.datastore.inputs;
    var inputIdx = 0;
    var f = [];
    do {
      (function() {
        var inputIdxCopy = inputIdx;
        f[inputIdxCopy] = function(callback) {
          var input = inputs[inputIdxCopy];
          var hashStr = input.txid;
          self.rpc.getRawTransaction(hashStr, function(err, resp) {
            if (err) throw new Error(err['message']);

            var txhash = resp['result'];

            if (!self.datastore.inputtxs)
              self.datastore.inputtxs = {};

            self.datastore.inputtxs[hashStr]=txhash;

            callback();
          });
        }
      })();

      inputIdx++;
    } while (inputIdx < inputs.length);

    async.series(f,function(err){self.write_datastore(function() {})});
  }
  
  Cosign.prototype.cmd_outputs = function()
  {
    if (this.datastore['outputs'] == undefined)
      this.datastore['outputs'] = {};
  
    for (var i = 1; i < this.program.args.length; i += 2) {
      var addr = String(this.program.args[i]);
      var value = this.program.args[i + 1];
  
      this.datastore['outputs'][addr] = value;
    }
  
    this.write_datastore(function(err) {});
  }
  
  Cosign.prototype.cmd_raw = function(in_str, append)
  {
    var re = new RegExp('([\\da-fA-F]+)');
    in_str = String(in_str);
    var matches = in_str.match(re);
    if (matches == null)
      throw new Error("Hex transaction data not supplied");
  
    var hexstr = matches[1];
    if (append && this.datastore['raw'])
      this.datastore['raw'] += hexstr;
    else
      this.datastore['raw'] = hexstr;
  
    this.write_datastore(function(err) {});
  }
  
  Cosign.prototype.cmd_raw_create_internal = function()
  {
    var self = this;
    var txobj = {};
    txobj.version = 1;
    txobj.lock_time = 0;
    txobj.ins = [];
    txobj.outs = [];
  
    this.datastore.inputs.forEach(function(inputobj) {
      var txin = {};
      txin.s = coinUtil.EMPTY_BUFFER;
      txin.q = 0xffffffff;
  
      var hash = new Buffer(inputobj.txid, 'hex');
      buffertools.reverse(hash);
      var vout = parseInt(inputobj.vout);
      var voutBuf = new Buffer(4);
      voutBuf.writeUInt32LE(vout, 0);
  
      txin.o = Buffer.concat([hash, voutBuf]);
  
      txobj.ins.push(txin);
    });
  
    var keys = Object.keys(this.datastore.outputs);
    keys.forEach(function(addrStr) {
      var addr = new Address(addrStr);
      var version = addr.version()

      if (version == networks.livenet.addressPubkey || version == networks.testnet.addressPubkey)
        var script = Script.createPubKeyHashOut(addr.payload());
      else if (version == networks.livenet.addressScript || version == networks.testnet.addressScript)
        var script = Script.createP2SH(addr.payload());
      else
        throw new Error('invalid output address');
  
      var valueNum = coinUtil.parseValue(self.datastore.outputs[addrStr]);
      var value = coinUtil.bigIntToValue(valueNum);
  
      var txout = {
        v: value,
        s: script.getBuffer(),
      };
  
      txobj.outs.push(txout);
    });
  
    var tx = new Transaction(txobj);
    this.cmd_raw(tx.serialize().toString('hex'), false);
  }
  
  Cosign.prototype.cmd_raw_create = function()
  {
    if (!this.datastore['inputs'] || !this.datastore['outputs'])
      throw new Error("missing inputs and/or outputs");
  
    this.cmd_raw_create_internal();
  }
  
  Cosign.prototype.raw_decode_cb = function(err, resp)
  {
    if (err) throw new Error(err['message']);
    console.log(coinUtil.inspect(resp['result'], {'depth':1000}));
  }
  
  Cosign.prototype.cmd_raw_decode = function()
  {
    var self = this;
    if (!this.datastore['raw'])
      throw new Error("Missing raw transaction");
  
    this.rpc.decodeRawTransaction(self.datastore['raw'], self.raw_decode_cb.bind(self));
  }
  
  Cosign.prototype.raw_get_cb = function(err, resp)
  {
    if (err) throw new Error(err['message']);
    this.cmd_raw(resp['result'], false);
  }
  
  Cosign.prototype.cmd_raw_get = function(txid)
  {
    var self = this;
    this.rpc.getRawTransaction(txid, self.raw_get_cb.bind(self));
  }
  
  Cosign.prototype.raw_append_cb = function(err, data)
  {
    if (err) throw err;
    this.cmd_raw(data, true);
  }
  
  Cosign.prototype.cmd_raw_append = function(filename)
  {
    var self = this;
    fs.readFile(filename, {'encoding':'utf8'}, self.raw_append_cb.bind(this));
  }
  
  Cosign.prototype.raw_read_cb = function(err, data)
  {
    if (err) throw err;
    this.cmd_raw(data, false);
  }
  
  Cosign.prototype.cmd_raw_read = function(filename)
  {
    var self = this;
    fs.readFile(filename, {'encoding':'utf8'}, self.raw_read_cb.bind(this));
  }
  
  Cosign.prototype.raw_send_cb = function(err, resp)
  {
    if (err) throw new Error(err['message']);
    console.log(resp['result']);
  }
  
  Cosign.prototype.cmd_raw_send = function()
  {
    var self = this;
    if (!this.datastore['raw'])
      throw new Error("Missing raw transaction");
  
    this.rpc.sendRawTransaction(self.datastore['raw'], self.raw_send_cb.bind(self));
  }
  
  Cosign.prototype.cmd_raw_sign_pubkeyhash = function(anypay, tx, i, scriptPubKey, txSigHash)
  {
    var pubKeyHash = scriptPubKey.captureOne();
    var wkey = this.wallet.findKeyHash(pubKeyHash);
    if (!wkey)
      return 0;    // did no work; signed nothing
  
    var wkey = new WalletKey({network: this.network});
    wkey.fromObj(wkeyObj);
  
    var sigRaw = wkey.privKey.signSync(txSigHash);
  
    var sigType = new Buffer(1);
    sigType[0] = anypay ? Transaction.SIGHASH_ANYONECANPAY : Transaction.SIGHASH_ALL;
  
    var sig = Buffer.concat([sigRaw, sigType]);
  
    var scriptSig = new Script();
    scriptSig.chunks.push(sig);
    scriptsig.chunks.push(wkey.privKey.public);
    scriptSig.updateBuffer();
  
    tx.ins[i].s = scriptSig.getBuffer();
  
    return 1;      // signed 1 signature
  }
  
  Cosign.prototype.pubkeyHexHash = function(pubkeyHex)
  {
    var pubkey = new Buffer(pubkeyHex, 'hex');
    var pubKeyHash = coinUtil.sha256ripe160(pubkey);
    return pubKeyHash;
  }
  
  Cosign.prototype.findByPubkey = function(pubkeyHex)
  {
    var pkh = pubkeyHexHash(pubkeyHex);
    var wkey = this.wallet.findKeyHash(pkh);
    return wkey;
  }
  
  Cosign.prototype.cmd_raw_sign_pubkey = function(anypay, tx, i, scriptPubKey, txSigHash)
  {
    var pubkey = scriptPubKey.captureOne();
    var pubKeyHash = coinUtil.sha256ripe160(pubkey);
    var wkeyObj = this.wallet.findKeyHash(pubKeyHash);
    if (!wkeyObj)
      return 0;    // did no work; signed nothing
  
    var wkey = new WalletKey({network: this.network});
    wkey.fromObj(wkeyObj);
  
    var sigRaw = wkey.privKey.signSync(txSigHash);
  
    var sigType = new Buffer(1);
    sigType[0] = anypay ? Transaction.SIGHASH_ANYONECANPAY : Transaction.SIGHASH_ALL;
  
    var sig = Buffer.concat([sigRaw, sigType]);
  
    var scriptSig = new Script();
    scriptSig.chunks.push(sig);
    scriptSig.updateBuffer();
  
    tx.ins[i].s = scriptSig.getBuffer();
  
    return 1;      // signed 1 signature
  }
  
  Cosign.prototype.updateMultiSig = function(scriptSigBuf, sig, index, n_keys)
  {
    if (!scriptSigBuf)
      scriptSigBuf = coinUtil.EMPTY_BUFFER;
    var scriptSig = new Script(scriptSigBuf);
  
    if (scriptSig.chunks.length < n_keys) {
      while (scriptSig.chunks.length < n_keys)
        scriptSig.chunks.push(coinUtil.EMPTY_BUFFER);
    }
    
    scriptSig.chunks[index] = sig;
    scriptSig.updateBuffer();
  
    return scriptSig.getBuffer();
  }
  
  Cosign.prototype.cmd_raw_sign_multisig = function(anypay, tx, i, scriptPubKey, txSigHash)
  {
    var self = this;
    var pubkeys = scriptPubKey.capture();
    var wkeys = {};
    var index = 0;
    var n_signed = 0;
    pubkeys.forEach(function(pubkey) {
      var pubKeyHash = coinUtil.sha256ripe160(pubkey);
      var wkeyObj = self.wallet.findKeyHash(pubKeyHash);
      if (wkeyObj) {
        var wkey = new WalletKey({network: self.network});
        wkey.fromObj(wkeyObj);
  
        var sigRaw = wkey.privKey.signSync(txSigHash);
  
        var sigType = new Buffer(1);
        sigType[0] = anypay? Transaction.SIGHASH_ANYONECANPAY : Transaction.SIGHASH_ALL;
  
        var sig = Buffer.concat([sigRaw, sigType]);
  
        tx.ins[i].s = self.updateMultiSig(tx.ins[i].s, sig,
              index, pubkeys.length);
        n_signed++;
      }
  
      index++;
    });
  
    return n_signed;
  }
  
  Cosign.prototype.cmd_raw_sign_scripthash = function(anypay, tx, i, scriptPubKey, txSigHash)
  {
    var scriptHash = scriptPubKey.capture()[0];
    var addr = new Address(this.network.addressScript, scriptHash);
    var addrStr = addr.as('base58');
    if (!(addrStr in this.wallet.datastore.scripts))
      return;
  
    var scriptHex = this.wallet.datastore.scripts[addrStr];
    var scriptBuf = new Buffer(scriptHex, 'hex');
    var scriptPubKey = new Script(scriptBuf);
    var scriptType = scriptPubKey.classify();
    var rc = -1;
  
    var txSigHash = tx.hashForSignature(scriptPubKey, i,
                 anypay ? Transaction.SIGHASH_ANYONECANPAY :
                 Transaction.SIGHASH_ALL);
    switch (scriptType) {
    case Script.TX_PUBKEYHASH:
      rc = this.cmd_raw_sign_pubkeyhash(anypay, tx, i, scriptPubKey, txSigHash);
      break;
    case Script.TX_MULTISIG:
      rc = this.cmd_raw_sign_multisig(anypay, tx, i, scriptPubKey, txSigHash);
      break;
    case Script.TX_PUBKEY:
      rc = this.cmd_raw_sign_pubkey(anypay, tx, i, scriptPubKey, txSigHash);
      break;
    default:
      return -1;
    }
  
    var scriptSigBuf = tx.ins[i].s;
    var scriptSig = new Script(scriptSigBuf);
    var len = scriptSig.chunks.length;
    var scriptBufNotAlreadyAppended = scriptSig.chunks[len-1] !== undefined && (typeof scriptSig.chunks[len-1] == "number" || scriptSig.chunks[len-1].toString('hex') != scriptBuf.toString('hex'));
    if (rc > 0 && scriptBufNotAlreadyAppended) {
      scriptSig.chunks.push(scriptBuf);
      scriptSig.updateBuffer();
      tx.ins[i].s = scriptSig.getBuffer();
    }
  
    if (scriptType == Script.TX_MULTISIG && scriptSig.finishedMultiSig())
    {
      scriptSig.removePlaceHolders();
      scriptSig.prependOp0();
      tx.ins[i].s = scriptSig.getBuffer();
    }
    
    return rc;
  
  }
  
  Cosign.prototype.cmd_raw_sign_internal2 = function(anypay, tx, inputIdx, scriptObj)
  {
    // console.dir(tx);
    var txin = tx.ins[inputIdx];
    if (!txin)
      return -2;  // invalid?
  
    var scriptBuf = new Buffer(scriptObj['hex'], 'hex');
    var scriptPubKey = new Script(scriptBuf);
    var scriptType = scriptPubKey.classify();
    if (txin.s.length > 0 && scriptType!=Script.TX_SCRIPTHASH && scriptType!=Script.TX_MULTISIG)
      return -1;  // already signed, did no work
    var rc = -1;
  
    var txSigHash = tx.hashForSignature(scriptPubKey, inputIdx,
                 anypay ? Transaction.SIGHASH_ANYONECANPAY :
                 Transaction.SIGHASH_ALL);
    switch (scriptType) {
    case Script.TX_UNKNOWN:
      break;
    case Script.TX_PUBKEYHASH:
      rc = this.cmd_raw_sign_pubkeyhash(anypay, tx, inputIdx, scriptPubKey, txSigHash);
      break;
    case Script.TX_SCRIPTHASH:
      rc = this.cmd_raw_sign_scripthash(anypay, tx, inputIdx, scriptPubKey, txSigHash);
      break;
    case Script.TX_MULTISIG:
      rc = this.cmd_raw_sign_multisig(anypay, tx, inputIdx, scriptPubKey, txSigHash);
      break;
    case Script.TX_PUBKEY:
      rc = this.cmd_raw_sign_pubkey(anypay, tx, inputIdx, scriptPubKey, txSigHash);
      break;
    }
    
    return 0;    // did no work; signed nothing
  }
  
  Cosign.prototype.cmd_raw_sign_internal = function(anypay)
  {
    var self = this;
    var rawbuf = new Buffer(this.datastore['raw'], 'hex');
    var parser = new Parser(rawbuf);
    var tx = new Transaction();
    tx.parse(parser);
    var inputs = tx.inputs();
  
    var inputIdx = 0;
    var f=[];
    do {
      (function(){
        var inputIdxCopy = inputIdx;

        //inputtxs are in datastore
        if (self.datastore.inputtxs) {
          f[inputIdxCopy] = function(callback) {
            var intxid = self.datastore.inputs[inputIdxCopy].txid;
            var intxhex = self.datastore.inputtxs[intxid];
            var intxbuf = new Buffer(intxhex, 'hex');
            var intx = new Transaction();
            intx.parse(intxbuf);
            var outn = self.datastore.inputs[inputIdxCopy].vout;
            var out = intx.outs[outn];
            var outscript = out.getScript();
            var outscripthex = outscript.buffer.toString('hex');
            var scriptObj = {};
            scriptObj.hex = outscripthex;
            var rc = self.cmd_raw_sign_internal2(anypay, tx, inputIdxCopy, scriptObj);
            callback();
          }
          return;
        }

        //inputtxs are not in datastore - must talk to bitcoind
        f[inputIdxCopy] = function(callback) {
          var input = inputs[inputIdxCopy];
          var hashStr = coinUtil.formatHashFull(input[0]);
          self.rpc.getTxOut(hashStr, input[1], function(err, resp) {
            if (err) throw new Error(err['message']);
  
            var rpcres = resp['result'];
            var scriptObj = rpcres['scriptPubKey'];
  
            var rc = self.cmd_raw_sign_internal2(anypay, tx, inputIdxCopy, scriptObj);
  
            callback();
          });
        }
      })();
  
      inputIdx++;
    } while (inputIdx < inputs.length);
    
    async.series(f,function(err){self.raw_sign_wallet_cb(err, tx)});
  }
  
  Cosign.prototype.raw_sign_wallet_cb = function(err, tx)
  {
    if (err) throw new Error(err['message']);
    this.datastore['raw'] = tx.serialize().toString('hex');
    this.write_datastore(function(err){});
  }
  
  Cosign.prototype.raw_sign_cb = function(err, resp)
  {
    if (err) throw new Error(err['message']);
    var result = resp['result'];
    var hexstr = result['hex'];
    var complete = result['complete'];
  
    console.log(complete ? "sigs:complete" : "sigs:partial");
  
    if (hexstr != this.datastore['raw']) {
      this.datastore['raw'] = hexstr;
      console.log("raw:updated");
      this.write_datastore(function(err) {});
    } else
      console.log("raw:unchanged");
  }
  
  Cosign.prototype.cmd_raw_sign = function(start_idx)
  {
    var self = this;
    if (!this.datastore['raw'])
      throw new Error("Missing raw transaction");
  
    var anypay = false;
  
    // scan list of command line options
    for (var i = start_idx; i < this.program.args.length; i++) {
      switch (this.program.args[i]) {
      case "anyonecanpay":
        anypay = true;
        break;
  
      default:
        throw new Error("Unknown raw.sign option");
      }
    }
  
    if (this.wallet)
      this.cmd_raw_sign_internal(anypay)
    else
      this.rpc.signRawTransaction(self.datastore['raw'], null, null,
                 anypay ? 'ALL|ANYONECANPAY' : 'ALL',
                 raw_sign_cb);
  }
  
  Cosign.prototype.cmd_raw_write = function(filename)
  {
    var self = this;
    if (this.datastore['raw'] == undefined)
      throw new Error("No raw transaction data stored in memory");
    
    fs.writeFile(filename, self.datastore['raw'], function(err) {});
  }

  Cosign.prototype.cmd_validate_inputs_internal = function()
  {
    var self = this;
    var dbinputs = self.datastore.inputs;
    if (!dbinputs) return false;

    var raw = self.datastore.raw;
    if (!raw) return false;

    var tx = new Transaction();
    tx.parse(new Buffer(raw, 'hex'));

    var txinputs = tx.ins;

    if (txinputs.length != dbinputs.length)
      return false;

    var txHasInput = [];

    for (var i in dbinputs) {
      var dbinput = dbinputs[i];
      var dbinput_txid = dbinput.txid;
      var dbinput_n = dbinput.vout;

      txHasInput[i]=false;

      for (var j in txinputs) {
        var txinput = txinputs[j];
        var txinput_hash = txinput.getOutpointHash();
        var txinput_txid = coinUtil.formatHashFull(txinput_hash);
        var txinput_n = txinput.getOutpointIndex();

        if (dbinput_txid == txinput_txid && dbinput_n == txinput_n) {
          txHasInput[i]=true;
          break;
        }
      }

      if (!txHasInput[i])
        return false;
    }

    return true;
  }

  Cosign.prototype.cmd_validate_inputs = function()
  {
    var self = this;
    var valid = self.cmd_validate_inputs_internal();

    if (valid) {
      var inputs = self.datastore.inputs;
      for (var i in inputs) {
        var input = inputs[i];
        console.log(input.txid, input.vout);
      }
      console.log('Success: database inputs and transaction inputs are one-to-one.');
    }
    else
      console.log('Failure: inconsistency between database inputs and transaction inputs.');
  }

  Cosign.prototype.cmd_validate_inputtxs_internal = function()
  {
    self = this;

    var inputs = self.datastore.inputs;
    var inputtxs = self.datastore.inputtxs;

    for (var i in inputs) {
      var txid = inputs[i].txid;
      var txhex = inputtxs[txid];

      //check that input is in inputtxs
      if (txhex === undefined)
        return false;

      var txbuf = new Buffer(txhex, 'hex');
      var tx = new Transaction();
      tx.parse(txbuf);
      var txhash = coinUtil.formatHashFull(tx.getHash());

      //check that tx hashes to txid correctly
      if (txid !== txhash)
        return false;
    }

    return true;
  }

  Cosign.prototype.cmd_validate_inputtxs = function()
  {
    var self = this;
    var valid = self.cmd_validate_inputtxs_internal();

    if (valid)
      console.log('Success: inputtxs correspond to inputs.');
    else
      console.log('Failure: inconsistency between inputtxs and inputs.');
  }

  Cosign.prototype.cmd_validate_outputs_internal = function()
  {
    var self = this;
    var dboutputs = self.datastore.outputs;
    if (!dboutputs) return false;

    var raw = self.datastore.raw;
    if (!raw) return false;

    var tx = new Transaction();
    tx.parse(new Buffer(raw, 'hex'));

    var txoutputs = tx.outs;

    var dboutlen = 0;
    for (var dbouti in dboutputs)
      dboutlen++;
    if (txoutputs.length != dboutlen)
      return false;

    var txHasOutput = [];

    for (var i in dboutputs) {
      txHasOutput[i] = false;

      var dboutput_addrstr = i;
      var dboutput_addr = new Address(dboutput_addrstr);
      var dboutput_hash = dboutput_addr.payload();
      var dboutput_hashstr = dboutput_hash.toString('hex');
      var dboutput_val = coinUtil.parseValue(dboutputs[i]).toNumber();

      for (var j in txoutputs) {
        var txoutput = txoutputs[j];
        var script = txoutput.getScript();
        var txoutput_val = txoutput.getValue();

        if (script.isPubkeyHash())
          var txoutput_hash = script.chunks[2];
        else if (script.isP2SH())
          var txoutput_hash = script.chunks[1];
        else //other output tx types unsupported
          return false;

        var txoutput_hashstr = txoutput_hash.toString('hex');

        if (dboutput_hashstr == txoutput_hashstr && dboutput_val == txoutput_val)
          txHasOutput[i] = true;
      }

      if (!txHasOutput[i])
        return false;
    }

    return true;
  }

  Cosign.prototype.cmd_validate_outputs = function()
  {
    var self = this;
    var valid = self.cmd_validate_outputs_internal();

    if (valid) {
      for (var i in self.datastore.outputs) {
        console.log(i, self.datastore.outputs[i]);
      }
      console.log('Success: database outputs and transaction outputs are one-to-one.');
    }
    else
      console.log('Failure: inconsistency between database outputs and transaction outputs.');
  }

  Cosign.prototype.cmd_validate_p2sh_file = function()
  {
    var self = this;

    var networkstr = self.wallet.datastore.network;
    var network = networks[networkstr];
    var version = network.addressScript;
    var buf = new Buffer(self.datastore.redeemScript, 'hex');
    var hash = coinUtil.sha256ripe160(buf);
    var addr = new Address(version, hash);
    var addrStr = addr.as('base58');

    var wscript = self.wallet.datastore.scripts[addrStr];
    var redeem = self.datastore.redeemScript;

    if (redeem == wscript && redeem.length > 0) {
      return addrStr;
    }
    else
      return false;
  }
  
  Cosign.prototype.cmd_validate_p2sh_rpc = function()
  {
    console.log('Failure: validate.p2sh for bitcoind wallet not implemented yet.');
  }

  Cosign.prototype.cmd_validate_p2sh = function()
  {
    var self = this;
    var addrStr;

    if (this.wallet)
      addrStr = this.cmd_validate_p2sh_file();
    else
      addrStr = this.cmd_validate_p2sh_rpc();

    if (addrStr) {
      console.log(addrStr);
      console.log('Success: p2sh address is valid and matches redeem script.');
    }
    else
      console.log('Failure: p2sh address is incorrect.');
  }
  
  Cosign.prototype.wallet_msig_cb = function(err, resp)
  {
    if (err) throw new Error(err['message']);
    console.log(resp['result']);
  }
  
  Cosign.prototype.cmd_wallet_msig_rpc = function()
  {
    var self = this;
    this.rpc.addMultiSigAddress(self.datastore['n_required'], self.datastore['pubkeys'],
               self.wallet_msig_cb);
  }
  
  Cosign.prototype.cmd_wallet_msig_file = function()
  {
    var pubkeys = this.wallet.expandKeys(this.datastore['pubkeys']);
    var script = Script.createMultisig(this.datastore['n_required'], pubkeys);
    var addrStr = this.wallet.addScript(script);
    this.wallet_store();
    console.log(addrStr);
  }
  
  Cosign.prototype.cmd_wallet_msig = function()
  {
    if (!this.datastore['n_required'] || !this.datastore['pubkeys'] || !this.datastore['redeemScript'])
      throw new Error("Missing N-Required and/or pubkeys and/or redeemScript");

    var check = this.cmd_validate_redeem_internal();
    if (!check)
      throw new Error("Pubkeys and n-req do not match redeemScript");
  
    if (this.wallet)
      this.cmd_wallet_msig_file();
    else
      this.cmd_wallet_msig_rpc();
  }
  
  Cosign.prototype.main = function()
  {
    var self = this;
    if (this.program.args.length == 0) {
      console.error("No command specified.");
      this.list_commands();
      return;
    }
  
    var cmd = this.program.args[0];
    
    if (cmd != 'init' && cmd != 'help' && cmd != 'clean') {
      try {
        this.datastore = JSON.parse(fs.readFileSync(self.statedb_fn));
      } catch(e) {
        console.error(this.statedb_fn, "must be a valid JSON file.  Run 'init' command to create a new one.");
        return;
      }
    }
  
    switch (cmd) {
  
    case "clean":
      this.remove_database(function(err) {});
      break;
  
    case "dump":
      console.dir(this.datastore);
      break;
  
    default:
      console.error("Unknown command", cmd);
      // fall through
  
    case "help":
      this.list_commands();
      return;
    
    case "init":
      this.write_datastore(function(err) {});
      break;
    
    case "inputs":
      this.cmd_inputs();
      break;
    case "inputs.clear":
      delete this.datastore['inputs'];
      this.write_datastore(function(err) {});
      break;

    case "inputtxs.clear":
      delete this.datastore['inputtxs'];
      this.write_datastore(function(err) {});
      break;
    case "inputtxs.get":
      this.cmd_inputtxs_get();
      break;
  
    case "multisig":
      this.cmd_multisig();
      break;
    
    case "nreq":
      this.cmd_nreq();
      break;

    case "redeem.clear":
      delete this.datastore['redeemScript'];
      this.write_datastore(function(err) {});
      break;
    case "redeem.create":
      this.cmd_redeem_create();
      break;
  
    case "outputs":
      this.cmd_outputs();
      break;
    case "outputs.clear":
      delete this.datastore['outputs'];
      this.write_datastore(function(err) {});
      break;
  
    case "pubkey.get":
      if (this.program.args.length < 2)
        throw new Error("Missing required address param");
      this.cmd_pubkey_get(this.program.args[1]);
      break;
    case "pubkeys":
      this.cmd_pubkeys();
      break;
    case "pubkeys.clear":
      delete this.datastore['pubkeys'];
      this.write_datastore(function(err) {});
      break;
  
    case "raw":
      if (this.program.args.length < 2)
        throw new Error("Missing required hex-string param");
      this.cmd_raw(this.program.args[1], false);
      break;
    case "raw.append":
      if (this.program.args.length < 2)
        throw new Error("Missing required filename param");
      this.cmd_raw_append(this.program.args[1]);
      break;
    case "raw.clear":
      delete this.datastore['raw'];
      this.write_datastore(function(err) {});
      break;
    case "raw.create":
      this.cmd_raw_create();
      break;
    case "raw.decode":
      this.cmd_raw_decode();
      break;
    case "raw.get":
      if (this.program.args.length < 2)
        throw new Error("Missing required txid param");
      this.cmd_raw_get(this.program.args[1]);
      break;
    case "raw.read":
      if (this.program.args.length < 2)
        throw new Error("Missing required filename param");
      this.cmd_raw_read(this.program.args[1]);
      break;
    case "raw.send":
      this.cmd_raw_send();
      break;
    case "raw.sign":
      this.cmd_raw_sign(1);
      break;
    case "raw.write":
      if (this.program.args.length < 2)
        throw new Error("Missing required filename param");
      this.cmd_raw_write(this.program.args[1]);
      break;

    case "validate.all":
      this.cmd_validate_all();
      break;
    case "validate.fees":
      this.cmd_validate_fees();
      break;
    case "validate.inputs":
      this.cmd_validate_inputs();
      break;
    case "validate.inputtxs":
      this.cmd_validate_inputtxs();
      break;
    case "validate.outputs":
      this.cmd_validate_outputs();
      break;
    case "validate.p2sh":
      this.cmd_validate_p2sh();
      break;
    case "validate.pubkeys":
      this.cmd_validate_pubkeys();
      break;
    case "validate.redeem":
      this.cmd_validate_redeem();
      break;
    case "validate.sigs":
      this.cmd_validate_sigs();
      break;
  
    case "wallet.msig":
      this.cmd_wallet_msig();
      break;
    }
  }
  return Cosign;
};
module.defineClass(spec);

if (require.main === module) {
  var Cosign = module.exports.class();
  var cosign = new Cosign(process.argv)
    cosign.main();
}
